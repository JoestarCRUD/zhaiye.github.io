<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ZMQ(3.2)官网文档翻译 第二章——套接字与模式 | 骡的岛技术小站</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2022-01-16T00:45:28.000Z" id="date"> 2022-01-16</time></span><br><span>updated:<time datetime="2022-02-10T15:25:02.509Z" id="updated"> 2022-02-10</time></span></div><h1>ZMQ(3.2)官网文档翻译 第二章——套接字与模式</h1><hr></div><div id="post-content"><h1 id="Chapter-2-Sockets-and-Patterns"><a href="#Chapter-2-Sockets-and-Patterns" class="headerlink" title="Chapter 2 - Sockets and Patterns"></a>Chapter 2 - Sockets and Patterns</h1><p>在<a href="/2021/11/14/ZeroMQ%E5%9F%BA%E7%A1%80/" title="ZMQ(3.2)官网文档翻译 第一章——基础知识">ZMQ(3.2)官网文档翻译 第一章——基础知识</a>中，我们以 ZeroMQ 为引子，提供了一些主要 ZeroMQ 模式的基本示例：请求-回复、发布-订阅和管道。在本章中，我们将亲自动手并开始学习如何在实际程序中使用这些工具。</p>
<p>我们将介绍：</p>
<ul>
<li>如何创建和使用 ZeroMQ 套接字。</li>
<li>如何在套接字上发送和接收消息。</li>
<li>如何围绕 ZeroMQ 的异步 I/O 模型构建您的应用程序。</li>
<li>如何在一个线程中处理多个套接字。</li>
<li>如何正确处理致命和非致命错误。</li>
<li>如何处理像 Ctrl-C 这样的中断信号。</li>
<li>如何干净地关闭 ZeroMQ 应用程序。</li>
<li>如何检查 ZeroMQ 应用程序是否存在内存泄漏。</li>
<li>如何发送和接收多部分消息。</li>
<li>如何跨网络转发消息。</li>
<li>如何构建一个简单的消息队列代理。</li>
<li>如何使用 ZeroMQ 编写多线程应用程序。</li>
<li>如何使用 ZeroMQ 在线程之间发信号。</li>
<li>如何使用 ZeroMQ 来协调节点网络。</li>
<li>如何为 pub-sub 创建和使用消息信封。</li>
<li>使用 HWM（高水位线）来防止内存溢出。</li>
</ul>
<h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>&emsp;&emsp;老实说，ZeroMQ 对你做了一种偷梁换柱，对此我们不道歉。这是为了你好，它对我们的伤害比对你的伤害更大。 ZeroMQ 提供了一个熟悉的基于套接字的 API，它需要我们付出很大的努力来隐藏一堆消息处理引擎。然而，结果会慢慢修正你关于如何设计和编写分布式软件的世界观。</p>
<p>&emsp;&emsp;套接字是用于网络编程的事实上的标准 API，也可以防止你惊掉下巴。使 ZeroMQ 对开发人员特别有吸引力的一件事是它使用套接字和消息而不是其他一些任意的概念集。感谢 Martin Sustrik 完成这项工作。它将“面向消息的中间件”这一主题完成得很棒。</p>
<p>就像最棒的菜品一样，ZeroMQ 套接字很容易消化。套接字的生命分为四个部分，就像 BSD 套接字一样：</p>
<ul>
<li>创建和销毁套接字，它们共同形成套接字的生命周期（参见 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-socket">zmq_socket()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_close">zmq_close()</a>）。</li>
<li>通过在套接字上设置选项并在必要时检查它们来配置套接字（参见 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-setsockopt">zmq_setsockopt()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-getsockopt">zmq_getsockopt()</a>）。</li>
<li>通过创建进出它们的 ZeroMQ 连接将套接字插入网络拓扑（参见 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-bind">zmq_bind()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-connect">zmq_connect()</a>）。</li>
<li>通过在套接字上写入和接收消息来携带数据，从而使用它们（参见 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-recv">zmq_msg_recv()</a>）。</li>
</ul>
<p>请注意，套接字始终是空指针，而消息（我们很快就会谈到）是结构。因此，在 C 中，您按原样传递套接字，但我们在所有处理消息的函数中传递消息地址，例如 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a> 和 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-recv">zmq_msg_recv()</a>。作为助记符，要意识到“在 ZeroMQ 中，您所有的套接字都属于我们”，但消息是您在代码中实际拥有的东西。(其实就是让开发人员不用关心套接字，专注于业务和消息就好，老外真是太罗嗦了)</p>
<p>创建、销毁和配置套接字就像您对任何对象所期望的那样工作。但请记住，ZeroMQ 是一种异步、弹性的结构。这对我们如何将套接字插入网络拓扑以及之后如何使用套接字有一些影响。</p>
<h3 id="将套接字插入拓扑"><a href="#将套接字插入拓扑" class="headerlink" title="将套接字插入拓扑"></a>将套接字插入拓扑</h3><p>要在两个节点之间创建连接，您可以在一个节点中使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-bind">zmq_bind()</a>，在另一个节点中使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-connect">zmq_connect()</a>。作为一般的经验法则，执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-bind">zmq_bind()</a> 的节点是一个“服务端”，位于一个众所周知的网络地址上，而执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-connect">zmq_connect()</a> 的节点是一个“客户端”，具有未知或任意的网络地址。因此，我们说我们“将套接字绑定到endpoint”和“将套接字连接到endpoint”，endpoint是那个众所周知的网络地址。</p>
<p>ZeroMQ 连接与经典的 TCP 连接有些不同。主要的显着差异是：</p>
<ul>
<li>它们通过任意协议传输（inproc、ipc、tcp、pgm 或 epgm）。 参见 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-inproc">zmq_inproc()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-ipc">zmq_ipc()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-tcp">zmq_tcp()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-pgm">zmq_pgm()</a> 和 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_epgm">zmq_epgm()</a>。</li>
<li>一个套接字可能有许多传出传入连接。</li>
<li>没有 zmq_accept() 方法。 当套接字绑定到endpoint时，它会自动开始接受连接。</li>
<li>网络连接本身发生在后台，如果网络连接中断（例如，如果对等方消失然后又回来），ZeroMQ 将自动重新连接。</li>
<li>您的应用程序代码不能直接使用这些连接； 它们封装在socket底层。</li>
</ul>
<p>许多架构遵循某种C/S模型，其中服务端是最静态的组件，而客户端是最动态的组件，即它们来来往往最多。有时存在寻址问题：服务端对客户端可见，但不一定反之亦然。所以大多数情况下，哪个节点应该执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-bind">zmq_bind()</a>（服务端）和哪个节点应该执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-connect">zmq_connect()</a>（客户端）是显而易见的。它还取决于您使用的套接字类型，不寻常的网络架构除外。稍后我们将查看套接字类型。</p>
<p>现在，假设我们在启动服务端之前启动客户端。在传统网络中，我们会看到一个很大的红色失败标志。但是 ZeroMQ 让我们可以任意开始和停止片段。一旦客户端节点执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-connect">zmq_connect()</a>，连接就存在并且该节点可以开始向套接字写入消息。在某个阶段（希望在消息在排队到以至于它们开始被丢弃或客户端阻塞之前），服务端启动，执行 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-bind">zmq_bind()</a>，并且 ZeroMQ 开始传递消息。</p>
<p>服务端节点可以绑定到许多endpoint（即协议和地址的组合），并且它可以使用单个套接字完成此操作。这意味着它将接受跨不同传输的连接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">zmq_bind (socket, &quot;tcp://*:5555&quot;);<br>zmq_bind (socket, &quot;tcp://*:9999&quot;);<br>zmq_bind (socket, &quot;inproc://somename&quot;);<br></code></pre></td></tr></table></figure>

<p>对于大多数传输，您不能两次绑定到同一个endpoint，这与 UDP 不同。然而，ipc 协议可以，它确实允许让一个进程绑定到第一个进程已经使用过的endpoint上。它旨在允许进程在崩溃后恢复。</p>
<p>尽管 ZeroMQ 试图对哪一侧绑定和哪一侧连接保持中立，但还是存在差异。我们稍后会更详细地看到这些。结果是，您通常应该将“服务端”视为拓扑中绑定或多或少静态endpoint的静态部分，而将“客户端”视为来来往往并连接到这些endpoint的动态部分。然后，围绕此模型设计您的应用程序。它“正常工作”的可能性要好得多。</p>
<p>套接字有类型。套接字类型定义了套接字的语义、其向内和向外路由消息的策略、队列等。您可以将某些类型的套接字连接在一起，例如，发布者套接字和订阅者套接字。套接字以“消息模式”协同工作。稍后我们将更详细地研究这一点。</p>
<p>以这些不同的方式连接套接字的能力赋予了 ZeroMQ 作为消息队列系统的基本能力。在此之上还有其他层，例如代理，我们稍后会介绍。但本质上，使用 ZeroMQ，您可以通过像孩子的建筑玩具一样将各个部分连接在一起来定义您的网络架构。</p>
<h3 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h3><p>要发送和接收消息，您可以使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a> 和 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-recv">zmq_msg_recv()</a>） 方法。 名称是常规的，但 ZeroMQ 的 I/O 模型与经典的 TCP 模型有很大不同，您需要时间来了解它。</p>
<p><strong>Figure 9 - TCP sockets are 1 to 1</strong></p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig9.png" class="" title="Figure 9">

<p>在处理数据时，让我们看看 TCP 套接字和 ZeroMQ 套接字之间的主要区别：</p>
<ul>
<li>ZeroMQ 套接字承载消息，如 UDP，而不是像 TCP 那样的字节流。 ZeroMQ 消息是指定长度的二进制数据。 我们很快就会收到消息； 他们的设计针对性能进行了优化，因此有点棘手。</li>
<li>ZeroMQ 套接字在后台线程中执行它们的 I/O。 这意味着消息到达本地输入队列并从本地输出队列发送，无论您的应用程序忙于做什么。</li>
<li>根据套接字类型，ZeroMQ 套接字具有内置的一对 N 路由行为。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-send">zmq_send()</a> 方法实际上并不将消息发送到套接字连接。 它对消息进行排队，以便 I/O 线程可以异步发送它。 除了某些异常情况外，它不会阻塞。 因此，当 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-send">zmq_send()</a> 当您的应用程序获得返回时，ZeroMQ不一定真的会发送消息。</p>
<h3 id="单播传输"><a href="#单播传输" class="headerlink" title="单播传输"></a>单播传输</h3><p>ZeroMQ 提供了一组单播传输（inproc、ipc 和 tcp）和多播传输（epgm、pgm）。多播是一种高级技术，我们将在后面介绍。甚至不要开始使用它，除非您知道您的扇出比将使 1 比 N 单播成为不可能。</p>
<p>对于大多数常见情况，请使用 tcp，这是一种断开连接的 TCP 传输。对于大多数情况，它具有弹性、便携性和足够快的速度。我们称之为断开连接，因为 ZeroMQ 的 tcp 传输在您连接到它之前不需要endpoint存在。客户端和服务端可以随时连接和绑定，可以去和回来，并且它对应用程序保持透明。</p>
<p>进程间的ipc传输会断开，就像tcp一样。它有一个限制：它还不能在 Windows 上运行。按照惯例，我们使用带有“.ipc”扩展名的endpoint名称以避免与其他文件名的潜在冲突。在 UNIX 系统上，如果您使用 ipc endpoint，则需要使用适当的权限创建这些endpoint，否则它们可能无法在以不同用户 ID 运行的进程之间共享。您还必须确保所有进程都可以访问这些文件，例如，通过在同一工作目录中运行。</p>
<p>线程间传输 inproc 是一个连接的信令传输。它比 tcp 或 ipc 快得多。与 tcp 和 ipc 相比，此传输具有特定限制：<strong>服务端必须在任何客户端发出连接之前发出绑定</strong>。这已在 ZeroMQ v4.0 及更高版本中修复。</p>
<h3 id="ZeroMQ-不是一个中立的载体"><a href="#ZeroMQ-不是一个中立的载体" class="headerlink" title="ZeroMQ 不是一个中立的载体"></a>ZeroMQ 不是一个中立的载体</h3><p>ZeroMQ 新手问的一个常见问题（这是我问过自己的问题）是，“我如何在 ZeroMQ 中编写 xxx 服务器？” 例如，“我如何在 ZeroMQ 中编写 HTTP 服务器？” 这意味着如果我们使用普通套接字来承载 HTTP 请求和响应，我们应该能够使用 ZeroMQ 套接字来做同样的事情，只是更快更好。</p>
<p>过去的答案是“这不是它的工作方式”。 ZeroMQ 不是一个中立的载体：它在它使用的传输协议上强加了一个框架。 这种成帧与现有协议不兼容，这些协议倾向于使用自己的成帧。 例如，比较 HTTP 请求和 ZeroMQ 请求，两者都基于 TCP/IP</p>
<p><strong>Figure 10 - HTTP on the Wire</strong></p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig10.png" class="" title="Figure 10">

<p>HTTP 请求使用 CR-LF 作为其最简单的帧分隔符，而 ZeroMQ 使用指定长度的帧。 因此，您可以使用 ZeroMQ 编写类似 HTTP 的协议，例如使用请求-回复套接字模式。 但它不会是 HTTP。</p>
<p><strong>Figure 11 - ZeroMQ on the Wire</strong></p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig11.png" class="" title="Figure 11">

<p>然而，从 v3.3 开始，ZeroMQ 有一个名为 ZMQ_ROUTER_RAW 的套接字选项，它允许您在没有 ZeroMQ 框架的情况下读取和写入数据。 您可以使用它来读取和写入正确的 HTTP 请求和响应。 Hardeep Singh 贡献了这一更改，以便他可以从他的 ZeroMQ 应用程序连接到 Telnet 服务器。 在撰写本文时，这仍处于实验阶段，但它显示了 ZeroMQ 如何不断发展以解决新问题。 也许下一个补丁就是你需要的了。</p>
<h3 id="I-O-线程"><a href="#I-O-线程" class="headerlink" title="I/O 线程"></a>I/O 线程</h3><p>我们说过 ZeroMQ 在后台线程中进行 I/O。 除了最极端的应用程序外，一个 I/O 线程（对于所有套接字）就足够了。 当你创建一个新的上下文时，它从一个 I/O 线程开始。 一般的经验法则是允许每秒每 GB 数据输入或输出一个 I/O 线程。 要增加 I/O 线程的数量，请在创建任何套接字之前使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-ctx-set">zmq_ctx_set()</a> 调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> io_threads = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">void</span> *context = zmq_ctx_new ();<br>zmq_ctx_set (context, ZMQ_IO_THREADS, io_threads);<br>assert (zmq_ctx_get (context, ZMQ_IO_THREADS) == io_threads);<br></code></pre></td></tr></table></figure>

<p>我们已经看到一个套接字可以同时处理数十个甚至数千个连接。 这对您编写应用程序的方式具有根本性的影响。 传统的网络应用程序每个远程连接有一个进程或一个线程，并且该进程或线程处理一个套接字。 ZeroMQ 允许您将整个结构折叠为一个进程，然后根据需要将其分解以进行扩展。</p>
<p>如果您仅将 ZeroMQ 用于线程间通信（即，没有外部套接字 I/O 的多线程应用程序），您可以将 I/O 线程设置为零。 不过，这不是一个重大的优化，更多的是好奇。</p>
<h3 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h3><p>在 ZeroMQ 套接字 API 的牛皮纸包装下面是消息传递模式的世界。如果您有企业消息传递方面的背景，或者非常了解 UDP，那么这些内容会比较熟悉。但是对于大多数 ZeroMQ 新手来说，它们是一个惊喜。我们已经习惯了 TCP 范式，其中套接字一对一地映射到另一个节点。</p>
<p>让我们简要回顾一下 ZeroMQ 为您做什么。它将数据块（消息）快速高效地传送到节点。您可以将节点映射到线程、进程或节点。 ZeroMQ 为您的应用程序提供了一个单一的套接字 API，无论实际传输是什么（如进程内、进程间、TCP 或多播）。当他们来来去去时，它会自动重新连接到对等点。它根据需要在发送方和接收方处对消息进行排队。它限制这些队列以防止进程耗尽内存。它处理套接字错误。它在后台线程中执行所有 I/O。它使用无锁技术在节点之间进行通信，因此永远不会有锁、等待、信号量或死锁。</p>
<p>但是通过这一点，它根据称为模式的精确配方路由和将消息排队。正是这些模式提供了 ZeroMQ 的智能性。它们概括了我们在分发数据和工作的最佳方式方面来之不易的经验。 ZeroMQ 的模式是硬编码的，但未来的版本可能允许用户定义模式。</p>
<p>ZeroMQ 模式由具有匹配类型的套接字对来实现。换句话说，要了解 ZeroMQ 模式，您需要了解套接字类型以及它们如何协同工作。大多数情况下，这只是需要学习；在这个层面上没有什么是显而易见的。</p>
<p>内置的核心 ZeroMQ 模式是：</p>
<ul>
<li><strong>Request-reply</strong>，将一组客户端连接到一组服务。 这是一个远程过程调用和任务分配模式。</li>
<li><strong>Pub-sub</strong>，将一组发布者连接到一组订阅者。 这是一种数据分布模式。</li>
<li><strong>Pipeline</strong>，以扇出/扇入模式连接节点，可以有多个步骤和循环。 这是一个并行的任务分配和收集模式。</li>
<li><strong>Exclusive pair</strong>，独占连接两个socket。 这是在一个进程中连接两个线程的模式，不要与“正常”的套接字对混淆。</li>
</ul>
<p>我们在 <a href="/2021/11/14/ZeroMQ%E5%9F%BA%E7%A1%80/" title="ZMQ(3.2)官网文档翻译 第一章——基础知识">ZMQ(3.2)官网文档翻译 第一章——基础知识</a> 中查看了其中的前三个，我们将在本章后面看到独占对模式。 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-socket">zmq_socket()</a> 文档对模式说明得相当清楚——值得多读几遍，直到它开始变得有意义。 这些是对连接绑定对有效的套接字组合（任何一方都可以绑定）：</p>
<ul>
<li>PUB and SUB</li>
<li>REQ and REP</li>
<li>REQ and ROUTER (注意，REQ 插入了一个额外的空帧)</li>
<li>DEALER and REP (注意，REP 假设是一个空帧)</li>
<li>DEALER and ROUTER</li>
<li>DEALER and DEALER</li>
<li>ROUTER and ROUTER</li>
<li>PUSH and PULL</li>
<li>PAIR and PAIR</li>
</ul>
<p>您还会看到对 XPUB 和 XSUB 套接字的引用，我们稍后会谈到（它们就像 PUB 和 SUB 的原始版本）。 任何其他组合都会产生未记录和不可靠的结果，如果您尝试使用它们，ZeroMQ 的未来版本可能会返回错误。 当然，您可以并且将会通过代码桥接其他套接字类型，即从一种套接字类型读取并写入另一种套接字类型。</p>
<h3 id="高级消息传递模式"><a href="#高级消息传递模式" class="headerlink" title="高级消息传递模式"></a>高级消息传递模式</h3><p>以下四个核心模式被集成到 ZeroMQ。 它们是 ZeroMQ API 的一部分，在核心 C++ 库中实现，并保证可用。</p>
<p>在这些之上，我们添加了<em>高级消息传递模式</em>。 我们在 ZeroMQ 之上构建这些高级模式，并可以支持几乎所有编程语言。 它们不是核心库的一部分，不随 ZeroMQ 包一起提供，并且作为 ZeroMQ 社区的一部分存在于自己的空间中。 例如，我们在 Chapter 4 - Reliable Request-Reply Patterns中探讨的 Majordomo 模式位于 ZeroMQ 组织的 GitHub Majordomo 项目中。</p>
<p>我们在本书中旨在为您提供的一件事是一组这样的高级模式，即小（如何恰当地处理消息）也大（如何制作可靠的发布-订阅架构）。</p>
<h3 id="和消息共事"><a href="#和消息共事" class="headerlink" title="和消息共事"></a>和消息共事</h3><p>libzmq 核心库实际上有两个 API 来发送和接收消息。 我们已经看到和使用的 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-send">zmq_send()</a> 和 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-recv">zmq_recv()</a> 方法是简单的单行代码。 我们会经常使用这些，但是 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-recv">zmq_recv()</a> 不擅长处理任意大小的消息：它会将消息截断为您提供的任何缓冲区大小。 所以还有第二个 API 与 zmq_msg_t 结构一起工作，具有更丰富但更困难的 API：</p>
<ul>
<li>初始化消息：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init">zmq_msg_init()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-size">zmq_msg_init_size()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-data">zmq_msg_init_data()</a>。</li>
<li>发送和接收消息：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-recv">zmq_msg_recv()</a>。</li>
<li>发布消息：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-close">zmq_msg_close()</a>。</li>
<li>访问消息内容：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-data">zmq_msg_data()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-size">zmq_msg_size()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-more">zmq_msg_more()</a>。</li>
<li>使用消息属性：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-get">zmq_msg_get()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-set">zmq_msg_set()</a>。</li>
<li>消息操作：<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-copy">zmq_msg_copy()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-move">zmq_msg_move()</a>。</li>
</ul>
<p>在网络上，ZeroMQ 消息是从零到适合内存的任意大小的 blob。 您可以使用协议缓冲区、msgpack、JSON 或您的应用程序需要使用的任何其他内容进行自己的序列化。 选择可移植的数据表示是明智的，但您可以自行决定权衡。</p>
<p>在内存中，ZeroMQ 消息是 zmq_msg_t 结构（或取决于您的语言的类）。 以下是在 C 中使用 ZeroMQ 消息的基本规则：</p>
<ul>
<li>您创建并传递 zmq_msg_t 对象，而不是数据块。</li>
<li>要读取消息，您可以使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init">zmq_msg_init()</a> 创建一个空消息，然后将其传递给 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-recv">zmq_msg_recv()</a>。</li>
<li>要从新数据写入消息，请使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-size">zmq_msg_init_size()</a> 创建消息并同时分配一定大小的数据块。然后使用 memcpy 填充该数据，并将消息传递给 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a>。</li>
<li>要释放（而不是销毁）消息，请调用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-close">zmq_msg_close()</a>。这会删除一个引用，最终 ZeroMQ 将销毁该消息。</li>
<li>要访问消息内容，请使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-data">zmq_msg_data()</a>。要知道消息包含多少数据，请使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-size">zmq_msg_size()</a>。</li>
<li>不要使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-move">zmq_msg_move()</a>、<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-copy">zmq_msg_copy()</a> 或 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-data">zmq_msg_init_data()</a> 除非你阅读了文档并确切地知道你为什么需要这些。</li>
<li>在您将消息传递给 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a> 后，ØMQ 将清除该消息，即将大小设置为零。同一条消息不能发送两次，发送后也无法访问消息数据。</li>
<li>如果您使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-send">zmq_send()</a> 和 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-recv">zmq_recv()</a>，则这些规则不适用，向它们传递字节数组，而不是消息结构。</li>
</ul>
<p>如果你想多次发送相同的消息，而且它的规模很大，创建第二条消息，使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-data">zmq_msg_init_data()</a> 初始化它，然后使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-copy">zmq_msg_copy()</a> 创建第一条消息的副本。 这不会复制数据，而是复制引用。 然后，您可以发送消息两次（或更多，如果您创建更多副本），并且只有在发送或关闭最后一个副本时，消息才会最终被销毁。</p>
<p>ZeroMQ 还支持multipart消息，它允许您将帧列表作为单个在线消息发送或接收。 这在实际应用中被广泛使用，我们将在本章后面和 Chapter 3 - Advanced Request-Reply Patterns中介绍。</p>
<p>帧（在 ZeroMQ 参考文档中也称为“消息的各部分”）是 ZeroMQ 消息的基本网络格式。 帧是指定长度的数据块。 长度向上可以为零。 如果您做过任何 TCP 编程，您就会明白为什么帧是“我现在应该从这个网络套接字读取多少数据？”这个问题的有用答案。</p>
<p>有一个称为 ZMTP 的传输级协议，它定义了 ZeroMQ 如何在 TCP 连接上读取和写入帧。 如果您对它的工作原理感兴趣，可以读一读，规范很短。</p>
<p>最初，ZeroMQ 消息是一帧，就像 UDP。 我们后来使用multipart消息对其进行了扩展，这些消息非常简单地是一系列帧，其中“more”位设置为 1，然后是该位设置为 0 的一个。 然后，ZeroMQ API 允许您编写带有“more”标志的消息，当您阅读消息时，它可以让您检查是否有“more”。</p>
<p>因此，在低级 ZeroMQ API 和参考手册中，关于消息与帧的关系有些模糊。 所以这是一个有用的规范：</p>
<ul>
<li>一条消息可以是一个或多个部分。</li>
<li>这些部分也称为“帧”。</li>
<li>每个部分都是一个 zmq_msg_t 对象。</li>
<li>您在低级 API 中分别发送和接收每个部分。</li>
<li>更高级别的 API 提供包装器来发送整个multipart消息。</li>
</ul>
<p>关于消息的其他一些值得了解的事情：</p>
<ul>
<li>您可以发送零长度消息，例如，用于将信号从一个线程发送到另一个线程。</li>
<li>ZeroMQ 保证交付消息的所有部分（一个或多个），或者一个都不提供。</li>
<li>ZeroMQ 不会立即发送消息（单部分或多部分），而是在以后某个不确定的时间发送。 因此，multipart消息必须相对内存大小合适。</li>
<li>消息（single或multipart）必须相对内存大小合适。 如果您想发送任意大小的文件，您应该将它们分成几部分，并将每一部分作为单独的单部分消息发送。 <strong>使用multipart数据不会减少内存消耗。</strong></li>
<li>针对那些不会在作用域范围内帮你自动销毁对象的语言，你必须在接收到的消息完成后调用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-close">zmq_msg_close()</a> 。发送消息后不要调用此方法。</li>
</ul>
<p>再重申一次，暂时不要使用 zmq_msg_init_data() 。 这是一种零拷贝的方法，保证会给你带来麻烦。 在您开始担心削减微秒之前，ZeroMQ还有更重要的事情需要你了解。</p>
<p>使用这个丰富的 API 可能会令人厌烦。 这些方法针对性能而不是简单性进行了优化。 如果你开始使用这些，你几乎肯定会弄错，除非你仔细阅读了文档。 因此，良好的语言绑定的主要工作之一是将此 API 包装在更易于使用的类中。</p>
<h3 id="处理多个套接字"><a href="#处理多个套接字" class="headerlink" title="处理多个套接字"></a>处理多个套接字</h3><p>在到目前为止的所有示例中，大多数示例的主循环是：</p>
<ul>
<li>等待套接字上的消息。</li>
<li>处理消息。</li>
<li>重复。</li>
</ul>
<p>如果我们想同时从多个endpoints 读取怎么办？ 最简单的方法是将一个套接字连接到所有endpoints ，并让 ZeroMQ 为我们做扇入。 如果远程endpoints 采用相同的模式，这是合法的，但将 PULL 套接字连接到 PUB endpoints 是错误的。</p>
<p>要真正同时从多个套接字读取，请使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-poll">zmq_poll()</a>。 更好的方法可能是将 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-poll">zmq_poll()</a> 包装在一个框架中，将其变成一个很好的事件驱动的反应器，但它比我们想在这里介绍的工作要多得多。</p>
<p>让我们从一个肮脏的 hack 开始，部分是为了说点不正确但快乐的事情，但主要是通过它让我向您展示如何进行非阻塞套接字读取。 这是使用非阻塞读取从两个套接字读取的简单示例。 这个相当混乱的程序既充当天气更新的订阅者，又充当并行任务的工作者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Reading from multiple sockets in Java</span><br><span class="hljs-comment">//  This version uses a simple recv loop</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">msreader</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and sockets</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">// Connect to task ventilator</span><br>            ZMQ.Socket receiver = context.createSocket(SocketType.PULL);<br>            receiver.connect(<span class="hljs-string">&quot;tcp://localhost:5557&quot;</span>);<br><br>            <span class="hljs-comment">//  Connect to weather server</span><br>            ZMQ.Socket subscriber = context.createSocket(SocketType.SUB);<br>            subscriber.connect(<span class="hljs-string">&quot;tcp://localhost:5556&quot;</span>);<br>            subscriber.subscribe(<span class="hljs-string">&quot;10001 &quot;</span>.getBytes(ZMQ.CHARSET));<br><br>            <span class="hljs-comment">//  Process messages from both sockets</span><br>            <span class="hljs-comment">//  We prioritize traffic from the task ventilator</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">//  Process any waiting tasks</span><br>                <span class="hljs-keyword">byte</span>[] task;<br>                <span class="hljs-keyword">while</span> ((task = receiver.recv(ZMQ.DONTWAIT)) != <span class="hljs-keyword">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;process task&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">//  Process any waiting weather updates</span><br>                <span class="hljs-keyword">byte</span>[] update;<br>                <span class="hljs-keyword">while</span> ((update = subscriber.recv(ZMQ.DONTWAIT)) != <span class="hljs-keyword">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;process weather update&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">//  No activity, so sleep for 1 msec</span><br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方法的代价是第一条消息的一些额外延迟（循环结束时的睡眠，当没有等待处理的消息时）。 在亚毫秒级延迟至关重要的应用程序中，这将是一个问题。 此外，您需要检查 nanosleep() 或您使用的任何函数的文档，以确保它不会忙循环。</p>
<p>您可以通过先从一个读取然后从第二个读取来公平地对待套接字，而不是像我们在这个例子中那样优先考虑它们。</p>
<p>现在让我们看看使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-poll">zmq_poll()</a> 正确完成相同无意义的小应用程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Reading from multiple sockets in Java</span><br><span class="hljs-comment">//  This version uses ZMQ.Poller</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mspoller</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">// Connect to task ventilator</span><br>            ZMQ.Socket receiver = context.createSocket(SocketType.PULL);<br>            receiver.connect(<span class="hljs-string">&quot;tcp://localhost:5557&quot;</span>);<br><br>            <span class="hljs-comment">//  Connect to weather server</span><br>            ZMQ.Socket subscriber = context.createSocket(SocketType.SUB);<br>            subscriber.connect(<span class="hljs-string">&quot;tcp://localhost:5556&quot;</span>);<br>            subscriber.subscribe(<span class="hljs-string">&quot;10001 &quot;</span>.getBytes(ZMQ.CHARSET));<br><br>            <span class="hljs-comment">//  Initialize poll set</span><br>            ZMQ.Poller items = context.createPoller(<span class="hljs-number">2</span>);<br>            items.register(receiver, ZMQ.Poller.POLLIN);<br>            items.register(subscriber, ZMQ.Poller.POLLIN);<br><br>            <span class="hljs-comment">//  Process messages from both sockets</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-keyword">byte</span>[] message;<br>                items.poll();<br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">0</span>)) &#123;<br>                    message = receiver.recv(<span class="hljs-number">0</span>);<br>                    System.out.println(<span class="hljs-string">&quot;Process task&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">1</span>)) &#123;<br>                    message = subscriber.recv(<span class="hljs-number">0</span>);<br>                    System.out.println(<span class="hljs-string">&quot;Process weather update&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>item结构体有四个成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">void</span> *socket;       <span class="hljs-comment">//  ZeroMQ socket to poll on</span><br>    <span class="hljs-keyword">int</span> fd;             <span class="hljs-comment">//  OR, native file handle to poll on</span><br>    <span class="hljs-keyword">short</span> events;       <span class="hljs-comment">//  Events to poll on</span><br>    <span class="hljs-keyword">short</span> revents;      <span class="hljs-comment">//  Events returned after poll</span><br>&#125; <span class="hljs-keyword">zmq_pollitem_t</span>;<br></code></pre></td></tr></table></figure>

<h2 id="Multipart消息"><a href="#Multipart消息" class="headerlink" title="Multipart消息"></a>Multipart消息</h2><p>ZeroMQ 允许我们从几个帧中组合一条消息，给我们一个“Multipart消息”。 现实应用程序大量使用Multipart消息，用于用地址信息包装消息和简单的序列化。 稍后我们将查看回复封装。</p>
<p>我们现在将学习的只是如何在任何需要转发消息而不检查消息的应用程序（例如代理）中盲目安全地读取和写入Multipart消息。</p>
<p>当您使用Multipart消息时，每个部分都是一个 zmq_msg 项目。 例如，如果您要发送包含五个部分的消息，则必须构造、发送和销毁五个 zmq_msg 项。 您可以提前执行此操作（并将 zmq_msg 项存储在数组或其他结构中），也可以在发送时一个接一个。</p>
<p>以下是我们如何在Multipart消息中发送帧（我们将每个帧接收到消息对象中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">zmq_msg_send (&amp;message, socket, ZMQ_SNDMORE);<br>...<br>zmq_msg_send (&amp;message, socket, ZMQ_SNDMORE);<br>...<br>zmq_msg_send (&amp;message, socket, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>以下是我们接收和处理消息中所有部分的方式，无论是单部分还是多部分： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">zmq_msg_t</span> message;<br>    zmq_msg_init (&amp;message);<br>    zmq_msg_recv (&amp;message, socket, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//  Process the message frame</span><br>    ...<br>    zmq_msg_close (&amp;message);<br>    <span class="hljs-keyword">if</span> (!zmq_msg_more (&amp;message))<br>        <span class="hljs-keyword">break</span>;      <span class="hljs-comment">//  Last message frame</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于multipart消息需要了解的一些事情：</p>
<ul>
<li>当您发送multipart消息时，第一部分（以及所有后续部分）仅在您发送最后一部分时才实际通过线路发送。</li>
<li>如果您正在使用 zmq_poll()，当您收到消息的第一部分时，其余所有部分也已到达。</li>
<li>您将收到一条消息的所有部分，或者根本没有。</li>
<li>消息的每一部分都是一个单独的 zmq_msg 项。</li>
<li>无论您是否检查 more 属性，您都会收到消息的所有部分。</li>
<li>在发送时，ZeroMQ 将消息帧在内存中排队，直到收到最后一个，然后将它们全部发送。</li>
<li>没有办法取消部分发送的消息，除非关闭套接字。</li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>ZeroMQ 旨在实现去中心化的智能，但这并不意味着您的网络中间是空白的。 它充满了消息感知基础设施，而且我们经常使用 ZeroMQ 构建该基础设施。 ZeroMQ 管道的范围可以从微小的管道到成熟的面向服务的brokers。 消息传递行业称之为<strong>intermediation</strong>(中介)，意思是这个中间的组件与任何一方打交道。 在 ZeroMQ 中，我们根据上下文将这些称为proxy、队列、转发器、设备或broker。</p>
<p>这种模式在现实世界中极为常见，这也是为什么我们的社会和经济中充斥着中介机构，这些中介机构除了降低大型网络的复杂性和扩展成本外，没有其他真正的功能。 现实世界中的中介通常称为批发商、分销商、经理等。</p>
<h3 id="动态发现的问题"><a href="#动态发现的问题" class="headerlink" title="动态发现的问题"></a>动态发现的问题</h3><p>当您设计更大的分布式架构时，您将遇到的问题之一是发现。 也就是说，如何让各个组件相互了解？ 如果组件经常来来去去，这会导致设计变得特别麻烦，所以我们称之为“动态发现的问题”。</p>
<p>动态发现有多种解决方案。 最简单的方法是通过硬编码（或配置）网络架构来完全避免它，因此发现是手动完成的。 也就是说，当您添加新作品时，您会重新配置网络以了解它。</p>
<p><strong>Figure 12 - Small-Scale Pub-Sub Network</strong></p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig12.png" class="" title="Figure 12">

<p>在实践中，这会导致越来越脆弱和笨拙的架构。 假设您有一个发布者和一百个订阅者。 您可以通过在每个订阅者中配置发布者端点将每个订阅者连接到发布者。 这很容易。 订阅者是动态的； 发布者是静态的。 现在假设您添加了更多发布者。 突然之间，这不再那么容易了。 如果继续将每个订阅者连接到每个发布者，避免动态发现的成本会越来越高。</p>
<p>Figure 13 - Pub-Sub Network with a Proxy</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig13.png" class="" title="Figure 13">

<p>对此有很多答案，但最简单的答案是添加一个中介；也就是说，网络中所有其他节点都连接到的静态点。在经典消息传递中，这是消息代理的工作。 ZeroMQ 本身没有消息代理，但它让我们可以很容易地构建中介。</p>
<p>您可能想知道，如果所有网络最终都变得足够大以需要中介，为什么我们不为所有应用程序简单地设置一个消息代理？对于初学者来说，这是一个公平的妥协。只要总是使用星型拓扑，忘记性能，事情通常会奏效。然而，消息代理是贪婪的。作为中央中介，它们变得太复杂、太有状态，最终成为一个问题。</p>
<p>最好将中介视为简单的无状态消息切换。一个很好的类比是 HTTP 代理；它在那里，但没有任何特殊作用。添加发布-订阅代理解决了我们示例中的动态发现问题。我们将代理设置在网络的“中间”。代理打开一个 XSUB 套接字和一个 XPUB 套接字，并将每个套接字绑定到众所周知的 IP 地址和端口。然后，所有其他进程连接到代理，而不是相互连接。添加更多订阅者或发布者变得轻而易举。</p>
<p>Figure 14 - Extended Pub-Sub</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig14.png" class="" title="Figure 14">

<p>我们需要 XPUB 和 XSUB 套接字，因为 ZeroMQ 负责从订阅者到发布者的订阅转发。 XSUB 和 XPUB 与 SUB 和 PUB 完全一样，只是它们将订阅公开为特殊消息。 代理必须通过从 XPUB 套接字读取这些订阅消息并将它们写入 XSUB 套接字，将这些订阅消息从订阅者端转发到发布者端。 这是 XSUB 和 XPUB 的主要用途。</p>
<h3 id="共享队列（DEALER-和-ROUTER-套接字）"><a href="#共享队列（DEALER-和-ROUTER-套接字）" class="headerlink" title="共享队列（DEALER 和 ROUTER 套接字）"></a>共享队列（DEALER 和 ROUTER 套接字）</h3><p>在 Hello World 客户端/服务端应用程序中，我们一个客户端与一个服务端对话。 但是，在实际情况下，我们通常需要允许多个服务端以及多个客户端。 这让我们可以扩大服务的能力（许多线程或进程或节点，而不仅仅是一个）。 唯一的限制是服务必须是无状态的，所有状态都在请求中或在一些共享存储（如数据库）中。</p>
<p>Figure 15 - Request Distribution</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig15.png" class="" title="Figure 15">

<p>有两种方法可以将多个客户端连接到多个服务端。暴力方法是将每个客户端套接字连接到多个服务端点。一个客户端套接字可以连接到多个服务套接字，然后 REQ 套接字将在这些服务之间分发请求。假设您将一个客户端套接字连接到三个服务端点； A、B 和 C。客户端发出请求 R1、R2、R3、R4。 R1和R4去服务A，R2去B，R3去服务C。</p>
<p>这种设计让您可以廉价地添加更多客户端。您还可以添加更多服务。每个客户端将其请求分发给服务。但是每个客户端都必须知道服务拓扑。如果您有 100 个客户端，然后决定再添加三个服务，则需要重新配置并重新启动 100 个客户端，以便客户端了解这三个新服务。</p>
<p>这显然不是我们在加班到凌晨 3 点还想要去做的事情，因为我们的超级计算集群资源耗尽，我们迫切需要添加数百个新服务节点。太多的静态片段就像混凝土（我也不知道是怎么能像的….）：消息是分布式的，你拥有的静态片段越多，改变拓扑结构所需要付出的努力就越多。我们想要的是位于客户端和服务端之间的东西，它可以集中所有拓扑知识。理想情况下，我们应该能够在不涉及拓扑的任何其他部分的情况下随时添加和删除服务端或客户端。</p>
<p>因此，我们将编写一个小消息队列代理，为我们提供这种灵活性。代理绑定到两个端点，客户端的前端和服务的后端。然后它使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_poll">zmq_poll()</a> 来监视这两个套接字的活动，当一些消息进入时，它会在两个套接字之间穿梭。它实际上并没有显式地管理任何队列——ZeroMQ 会在每个套接字上自动管理。</p>
<p>当您使用 REQ 与 REP 对话时，您会得到一个严格同步的请求-回复对话框。客户端发送请求。服务读取请求并发送回复。然后客户端读取回复。如果客户端或服务尝试执行任何其他操作（例如，连续发送两个请求而不等待响应），它们将收到错误消息。</p>
<p>但是我们的broker必须是非阻塞的。显然，我们可以使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_poll">zmq_poll()</a> 来等待任一套接字上的活动，但我们不能使用 REP 和 REQ。</p>
<p>Figure 16 - Extended Request-Reply</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig16.png" class="" title="Figure 16">

<p>幸运的是，有两个名为 DEALER 和 ROUTER 的套接字可以让您进行非阻塞请求-响应。 您将在第 3 章 - 高级请求-回复模式中看到 DEALER 和 ROUTER 套接字如何让您构建各种异步请求-回复流。 现在，我们将看看 DEALER 和 ROUTER 如何让我们将 REQ-REP 扩展到一个中介，即我们的小broker。</p>
<p>在这个简单的扩展请求-回复模式中，REQ 与 ROUTER 对话，DEALER 与 REP 对话。 在 DEALER 和 ROUTER 之间，我们必须有代码（如我们的broker）将消息从一个套接字拉出并将它们推送到另一个套接字。</p>
<p>请求-回复代理绑定到两个端点，一个供客户端连接（前端套接字），一个供worker连接（后端）。 要测试此代理，您需要更改您的worker，以便他们连接到后端套接字。 这是一个展示我的意思的客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Hello World client</span><br><span class="hljs-comment">* Connects REQ socket to tcp://localhost:5559</span><br><span class="hljs-comment">* Sends &quot;Hello&quot; to server, expects &quot;World&quot; back</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rrclient</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  Socket to talk to server</span><br>            Socket requester = context.createSocket(SocketType.REQ);<br>            requester.connect(<span class="hljs-string">&quot;tcp://localhost:5559&quot;</span>);<br><br>            System.out.println(<span class="hljs-string">&quot;launch and connect client.&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> request_nbr = <span class="hljs-number">0</span>; request_nbr &lt; <span class="hljs-number">10</span>; request_nbr++) &#123;<br>                requester.send(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">0</span>);<br>                String reply = requester.recvStr(<span class="hljs-number">0</span>);<br>                System.out.println(<br>                    <span class="hljs-string">&quot;Received reply &quot;</span> + request_nbr + <span class="hljs-string">&quot; [&quot;</span> + reply + <span class="hljs-string">&quot;]&quot;</span><br>                );<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是worker的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">//  Hello World worker</span><br><span class="hljs-comment">//  Connects REP socket to tcp://*:5560</span><br><span class="hljs-comment">//  Expects &quot;Hello&quot; from client, replies with &quot;World&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rrworker</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  Socket to talk to server</span><br>            Socket responder = context.createSocket(SocketType.REP);<br>            responder.connect(<span class="hljs-string">&quot;tcp://localhost:5560&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">//  Wait for next request from client</span><br>                String string = responder.recvStr(<span class="hljs-number">0</span>);<br>                System.out.printf(<span class="hljs-string">&quot;Received request: [%s]\n&quot;</span>, string);<br><br>                <span class="hljs-comment">//  Do some &#x27;work&#x27;</span><br>                Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                <span class="hljs-comment">//  Send reply back to client</span><br>                responder.send(<span class="hljs-string">&quot;World&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是代理，它可以正确处理多部分消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Poller;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Simple request-reply broker</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rrbroker</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and sockets</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            Socket frontend = context.createSocket(SocketType.ROUTER);<br>            Socket backend = context.createSocket(SocketType.DEALER);<br>            frontend.bind(<span class="hljs-string">&quot;tcp://*:5559&quot;</span>);<br>            backend.bind(<span class="hljs-string">&quot;tcp://*:5560&quot;</span>);<br><br>            System.out.println(<span class="hljs-string">&quot;launch and connect broker.&quot;</span>);<br><br>            <span class="hljs-comment">//  Initialize poll set</span><br>            Poller items = context.createPoller(<span class="hljs-number">2</span>);<br>            items.register(frontend, Poller.POLLIN);<br>            items.register(backend, Poller.POLLIN);<br><br>            <span class="hljs-keyword">boolean</span> more = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">byte</span>[] message;<br><br>            <span class="hljs-comment">//  Switch messages between sockets</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">//  poll and memorize multipart detection</span><br>                items.poll();<br><br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-comment">// receive message</span><br>                        message = frontend.recv(<span class="hljs-number">0</span>);<br>                        more = frontend.hasReceiveMore();<br><br>                        <span class="hljs-comment">// Broker it</span><br>                        backend.send(message, more ? ZMQ.SNDMORE : <span class="hljs-number">0</span>);<br>                        <span class="hljs-keyword">if</span> (!more) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-comment">// receive message</span><br>                        message = backend.recv(<span class="hljs-number">0</span>);<br>                        more = backend.hasReceiveMore();<br>                        <span class="hljs-comment">// Broker it</span><br>                        frontend.send(message, more ? ZMQ.SNDMORE : <span class="hljs-number">0</span>);<br>                        <span class="hljs-keyword">if</span> (!more) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Figure 17 - Request-Reply Broker</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig17.png" class="" title="Figure 17">

<p>使用请求-回复代理使您的客户端/服务器架构更容易扩展，因为客户端看不到worker，worker也看不到客户端。 唯一的静态节点是中间的代理。</p>
<h3 id="ZeroMQ的内置代理功能"><a href="#ZeroMQ的内置代理功能" class="headerlink" title="ZeroMQ的内置代理功能"></a>ZeroMQ的内置代理功能</h3><p>事实证明，上一节的 rrbroker 中的核心循环非常有用，并且可以重复使用。 它让我们可以轻松构建发布-订阅转发器、共享队列和其他小型中介。 ZeroMQ 将其封装在一个方法中，<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-proxy">zmq_proxy()</a>：</p>
<blockquote>
<p>zmq_proxy (frontend, backend, capture);</p>
</blockquote>
<p>两个（或三个套接字，如果我们想捕获数据）必须正确连接、绑定和配置。 当我们调用 zmq_proxy 方法时，就像启动 rrbroker 的主循环一样。 让我们重写 request-reply 代理来调用 zmq_proxy，并将其重新标记为一个听起来很昂贵的“消息队列”（人们已经向房子收取费用较少的代码）[译者注：这段奇奇怪怪的，我也实在翻译不通顺了orz]：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Simple message queuing broker</span><br><span class="hljs-comment">* Same as request-reply broker but using QUEUE device.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">msgqueue</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and sockets</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  Socket facing clients</span><br>            Socket frontend = context.createSocket(SocketType.ROUTER);<br>            frontend.bind(<span class="hljs-string">&quot;tcp://*:5559&quot;</span>);<br><br>            <span class="hljs-comment">//  Socket facing services</span><br>            Socket backend = context.createSocket(SocketType.DEALER);<br>            backend.bind(<span class="hljs-string">&quot;tcp://*:5560&quot;</span>);<br><br>            <span class="hljs-comment">//  Start the proxy</span><br>            ZMQ.proxy(frontend, backend, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你像大多数 ZeroMQ 用户一样，在这个阶段你的头脑开始思考，“如果我将随机套接字类型插入代理，我会做什么样的坏事？” 简短的回答是：尝试一下并弄清楚发生了什么。 在实践中，您通常会坚持使用 ROUTER/DEALER、XSUB/XPUB 或 PULL/PUSH。</p>
<h3 id="传输桥接"><a href="#传输桥接" class="headerlink" title="传输桥接"></a>传输桥接</h3><p>ZeroMQ 用户的一个常见请求是，“如何将我的 ZeroMQ 网络与技术 X 连接起来？” 其中 X 是其他一些网络或消息传递技术。<br>Figure 18 - Pub-Sub Forwarder Proxy</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig18.png" class="" title="Figure 18">

<p>简单的答案是建造一座<em>桥梁</em>。 桥接器是一个小型应用程序，它在一个套接字上使用一个协议，并在另一个套接字上to/from，即转换为从第二个协议。 一个协议解释器，如果你喜欢的话。 ZeroMQ 中一个常见的桥接问题是桥接两个传输或网络。</p>
<p>例如，我们将编写一个小代理，它位于发布者和一组订阅者之间，桥接两个网络。 前端套接字（SUB）面向天气服务器所在的内部网络，后端（PUB）面向外部网络上的订阅者。 它在前端套接字上订阅天气服务，并在后端套接字上重新发布其数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Weather proxy device.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">wuproxy</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and sockets</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  This is where the weather server sits</span><br>            Socket frontend = context.createSocket(SocketType.SUB);<br>            frontend.connect(<span class="hljs-string">&quot;tcp://192.168.55.210:5556&quot;</span>);<br><br>            <span class="hljs-comment">//  This is our public endpoint for subscribers</span><br>            Socket backend = context.createSocket(SocketType.PUB);<br>            backend.bind(<span class="hljs-string">&quot;tcp://10.1.1.0:8100&quot;</span>);<br><br>            <span class="hljs-comment">//  Subscribe on everything</span><br>            frontend.subscribe(ZMQ.SUBSCRIPTION_ALL);<br><br>            <span class="hljs-comment">//  Run the proxy until the user interrupts us</span><br>            ZMQ.proxy(frontend, backend, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它看起来与前面的代理示例非常相似，但关键部分是前端和后端套接字位于两个不同的网络上。 例如，我们可以使用此模型将多播网络（pgm 传输）连接到 tcp 发布者。</p>
<h2 id="处理错误和-ETERM"><a href="#处理错误和-ETERM" class="headerlink" title="处理错误和 ETERM"></a>处理错误和 ETERM</h2><p>ZeroMQ 的错误处理理念是快速失败和弹性的结合。我们认为，流程应该尽可能容易受到内部错误的影响，并尽可能稳健地抵御外部攻击和错误。打个比方，活细胞如果检测到一个内部错误就会自毁，但它会尽一切可能抵抗来自外部的攻击。</p>
<p>ZeroMQ 代码中的断言对于健壮的代码绝对是至关重要的。他们只需要在”蜂窝状细胞壁”的右侧。而且应该有这样一堵墙。如果不清楚故障是内部的还是外部的，那就是需要修复的设计缺陷。在 C/C++ 中，断言会在出现错误时立即停止应用程序。在其他语言中，您可能会遇到异常或停止。</p>
<p>当 ZeroMQ 检测到外部故障时，它会向调用代码返回一个错误。在极少数情况下，如果没有明显的从错误中恢复的策略，它会默默地丢弃消息。</p>
<p>到目前为止，在我们看到的大多数 C 示例中，都没有错误处理。<strong>真正的代码应该对每个 ZeroMQ 调用进行错误处理</strong>。如果您使用的是 C 以外的语言绑定，则该绑定可能会为您处理错误。在 C 中，您确实需要自己执行此操作。有一些简单的规则，从 POSIX 约定开始：</p>
<ul>
<li>创建对象的方法如果失败则返回 NULL。</li>
<li>处理数据的方法可能会返回已处理的字节数，或者在错误或失败时返回 -1。</li>
<li>其他方法在成功时返回 0，在错误或失败时返回 -1。</li>
<li>错误代码在 errno 或 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-errno">zmq_errno()</a> 中提供。</li>
<li><a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-strerror">zmq_strerror()</a> 提供了用于记录的描述性错误文本。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">void</span> *context = zmq_ctx_new ();<br>assert (context);<br><span class="hljs-keyword">void</span> *socket = zmq_socket (context, ZMQ_REP);<br>assert (socket);<br><span class="hljs-keyword">int</span> rc = zmq_bind (socket, <span class="hljs-string">&quot;tcp://*:5555&quot;</span>);<br><span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;E: bind failed: %s\n&quot;</span>, strerror (errno));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>您应该将两种主要的异常情况作为非致命情况处理：</p>
<ul>
<li>当您的代码收到带有 ZMQ_DONTWAIT 选项的消息并且没有等待数据时，ZeroMQ 将返回 -1 并将 errno 设置为 EAGAIN。</li>
<li>当一个线程调用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_ctx_destroy">zmq_ctx_destroy()</a>，而其他线程仍在做阻塞工作时，<a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_ctx_destroy">zmq_ctx_destroy()</a> 调用关闭上下文，所有阻塞调用以 -1 退出，并将 errno 设置为 ETERM。</li>
</ul>
<p>在 C/C++ 中，可以在优化代码中完全删除断言，所以不要错误地将整个 ZeroMQ 调用包装在 assert() 中。 它看起来很整洁； 然后优化器删除所有断言和您想要进行的调用，并且您的应用程序以令人印象深刻的方式中断。</p>
<p>Figure 19 - Parallel Pipeline with Kill Signaling</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig19.png" class="" title="Figure 19">

<p>让我们看看如何干净地关闭一个进程。 我们将采用上一节中的并行管道示例。 如果我们在后台启动了很多worker，我们现在想在批处理完成时杀死他们。 让我们通过向worker发送终止消息来做到这一点。 执行此操作的最佳位置是sink ，因为它确实知道批处理何时完成。</p>
<p>我们如何将接收器连接到worker？ PUSH/PULL 套接字仅是单向的。 我们可以切换到另一种套接字类型，或者我们可以混合多个套接字流。 让我们试试后者：使用 pub-sub 模型向worker发送终止消息：</p>
<ul>
<li>sink在新终端上创建一个 PUB 套接字。</li>
<li>worker将他们的输入套接字连接到此终端。</li>
<li>当sink检测到批处理结束时，它会向其 PUB 套接字发送终止消息。</li>
<li>当worker检测到此终止消息时，它会退出。</li>
</ul>
<p>在 sink 中不需要太多新代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">void</span> *controller = zmq_socket (context, ZMQ_PUB);<br>zmq_bind (controller, <span class="hljs-string">&quot;tcp://*:5559&quot;</span>);<br>...<br><span class="hljs-comment">//  Send kill signal to workers</span><br>s_send (controller, <span class="hljs-string">&quot;KILL&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这是worker进程，它使用我们之前看到的 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_poll">zmq_poll()</a> 技术管理两个套接字（一个 PULL 套接字获取任务，一个 SUB 套接字获取控制命令）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Task worker - design 2</span><br><span class="hljs-comment"> *  Adds pub-sub flow to receive and respond to kill signal</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">taskwork2</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            ZMQ.Socket receiver = context.createSocket(SocketType.PULL);<br>            receiver.connect(<span class="hljs-string">&quot;tcp://localhost:5557&quot;</span>);<br><br>            ZMQ.Socket sender = context.createSocket(SocketType.PUSH);<br>            sender.connect(<span class="hljs-string">&quot;tcp://localhost:5558&quot;</span>);<br><br>            ZMQ.Socket controller = context.createSocket(SocketType.SUB);<br>            controller.connect(<span class="hljs-string">&quot;tcp://localhost:5559&quot;</span>);<br>            controller.subscribe(ZMQ.SUBSCRIPTION_ALL);<br><br>            ZMQ.Poller items = context.createPoller(<span class="hljs-number">2</span>);<br>            items.register(receiver, ZMQ.Poller.POLLIN);<br>            items.register(controller, ZMQ.Poller.POLLIN);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                items.poll();<br><br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">0</span>)) &#123;<br><br>                    String message = receiver.recvStr(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">long</span> nsec = Long.parseLong(message);<br><br>                    <span class="hljs-comment">//  Simple progress indicator for the viewer</span><br>                    System.out.print(message + <span class="hljs-string">&#x27;.&#x27;</span>);<br>                    System.out.flush();<br><br>                    <span class="hljs-comment">//  Do the work</span><br>                    Thread.sleep(nsec);<br><br>                    <span class="hljs-comment">//  Send results to sink</span><br>                    sender.send(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-comment">//  Any waiting controller command acts as &#x27;KILL&#x27;</span><br>                <span class="hljs-keyword">if</span> (items.pollin(<span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Exit loop</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是修改后的sink应用程序。 当它完成收集结果时，它会向所有worker广播一条终止消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Task sink - design 2</span><br><span class="hljs-comment"> * Adds pub-sub flow to send kill signal to workers</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tasksink2</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and socket</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            ZMQ.Socket receiver = context.createSocket(SocketType.PULL);<br>            receiver.bind(<span class="hljs-string">&quot;tcp://*:5558&quot;</span>);<br><br>            <span class="hljs-comment">// Socket for worker control</span><br>            ZMQ.Socket controller = context.createSocket(SocketType.PUB);<br>            controller.bind(<span class="hljs-string">&quot;tcp://*:5559&quot;</span>);<br><br>            <span class="hljs-comment">//  Wait for start of batch</span><br>            receiver.recv(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">//  Start our clock now</span><br>            <span class="hljs-keyword">long</span> tstart = System.currentTimeMillis();<br><br>            <span class="hljs-comment">//  Process 100 confirmations</span><br>            <span class="hljs-keyword">int</span> task_nbr;<br>            <span class="hljs-keyword">for</span> (task_nbr = <span class="hljs-number">0</span>; task_nbr &lt; <span class="hljs-number">100</span>; task_nbr++) &#123;<br>                receiver.recv(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> ((task_nbr / <span class="hljs-number">10</span>) * <span class="hljs-number">10</span> == task_nbr) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;:&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    System.out.print(<span class="hljs-string">&quot;.&quot;</span>);<br>                &#125;<br>                System.out.flush();<br>            &#125;<br>            <span class="hljs-comment">//  Calculate and report duration of batch</span><br>            <span class="hljs-keyword">long</span> tend = System.currentTimeMillis();<br><br>            System.out.println(<br>                <span class="hljs-string">&quot;Total elapsed time: &quot;</span> + (tend - tstart) + <span class="hljs-string">&quot; msec&quot;</span><br>            );<br><br>            <span class="hljs-comment">//  Send the kill signal to the workers</span><br>            controller.send(<span class="hljs-string">&quot;KILL&quot;</span>, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">//  Give it some time to deliver</span><br>            Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="处理中断信号"><a href="#处理中断信号" class="headerlink" title="处理中断信号"></a>处理中断信号</h2><p>实际应用程序需要在被 Ctrl-C 或其他信号（如 SIGTERM）中断时干净地关闭。 默认情况下，这些只是杀死进程，这意味着消息不会被刷新，文件不会被干净地关闭，等等。以下是我们如何处理信号的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*  Interrupt in Java</span><br><span class="hljs-comment">*  Shows how to handle Ctrl-C</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQException;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">interrupt</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//  Prepare our context and socket</span><br>        <span class="hljs-keyword">final</span> ZContext context = <span class="hljs-keyword">new</span> ZContext();<br><br>        <span class="hljs-keyword">final</span> Thread zmqThread = <span class="hljs-keyword">new</span> Thread()<br>        &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            </span>&#123;<br>                ZMQ.Socket socket = context.createSocket(SocketType.REP);<br>                socket.bind(<span class="hljs-string">&quot;tcp://*:5555&quot;</span>);<br><br>                <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.recv(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (ZMQException e) &#123;<br>                        <span class="hljs-keyword">if</span> (e.getErrorCode() == ZMQ.Error.ETERM.getCode()) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                socket.setLinger(<span class="hljs-number">0</span>);<br>                socket.close();<br>            &#125;<br>        &#125;;<br><br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread()<br>        &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;W: interrupt received, killing server...&quot;</span>);<br>                context.close();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    zmqThread.interrupt();<br>                    zmqThread.join();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        zmqThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该程序提供 s_catch_signals()，它捕获 Ctrl-C (SIGINT) 和 SIGTERM。 当这些信号中的任何一个到达时，s_catch_signals() 处理程序设置全局变量 s_interrupted。 多亏了的信号处理程序，您的应用程序不会自动死亡。 相反，您有机会优雅地清理并退出。 您现在必须明确检查中断并正确处理它。 通过在主代码的开头调用 s_catch_signals()（从 interrupt.c 复制它）来执行此操作。 这设置了信号处理。 中断将影响 ZeroMQ 调用，如下所示：</p>
<ul>
<li>如果您的代码在阻塞调用（发送消息、接收消息或轮询）中被阻塞，那么当信号到达时，调用将返回 EINTR。</li>
<li>如果像 s_recv() 这样的包装器被中断，它们将返回 NULL。</li>
</ul>
<p>因此，请检查 EINTR 返回码、NULL 返回，或者 s_interrupted。</p>
<p>这是一个典型的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">s_catch_signals ();<br>client = zmq_socket (...);<br><span class="hljs-keyword">while</span> (!s_interrupted) &#123;<br>    <span class="hljs-keyword">char</span> *message = s_recv (client);<br>    <span class="hljs-keyword">if</span> (!message)<br>        <span class="hljs-keyword">break</span>;          <span class="hljs-comment">//  Ctrl-C used</span><br>&#125;<br>zmq_close (client);<br></code></pre></td></tr></table></figure>
<p>如果您调用 s_catch_signals() 并且不测试中断，那么您的应用程序将不受 Ctrl-C 和 SIGTERM 的影响，这可能有用，但通常没用。</p>
<h2 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h2><p>任何长时间运行的应用程序都必须正确管理内存，否则最终会耗尽所有可用内存并崩溃。 如果您使用一种可以自动为您处理此问题的语言，那么恭喜您。 如果您使用 C 或 C++ 或您负责内存管理的任何其他语言进行编程，这里有一个关于使用 valgrind 的简短教程，其中将报告您的程序存在的任何泄漏。</p>
<ul>
<li>要安装 valgrind，例如，在 Ubuntu 或 Debian 上，请发出以下命令：<blockquote>
<p>sudo apt-get install valgrind</p>
</blockquote>
</li>
<li>默认情况下，ZeroMQ 会让 valgrind 满腹牢骚。 要删除这些警告，请创建一个名为 vg.supp 的文件，其中包含以下内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs log">&#123;<br>   &lt;socketcall_sendto&gt;<br>   Memcheck:Param<br>   socketcall.sendto(msg)<br>   fun:send<br>   ...<br>&#125;<br>&#123;<br>   &lt;socketcall_sendto&gt;<br>   Memcheck:Param<br>   socketcall.send(msg)<br>   fun:send<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>使用 Ctrl-C 让您的程序干净地退出。 对于任何自行退出的应用程序，这是不需要的，但对于长时间运行的应用程序，这是必不可少的，否则 valgrind 会对当前分配的内存颇有微词。</li>
<li>如果它不是您的默认设置，请使用 -DDEBUG 构建您的应用程序。 这确保 valgrind 可以准确地告诉您内存泄漏的位置。</li>
<li>最后，运行 valgrind：</li>
</ul>
<blockquote>
<p>valgrind –tool=memcheck –leak-check=full –suppressions=vg.supp someprog  </p>
</blockquote>
<p>在修复它报告的任何错误后，您应该会收到令人愉快的消息：</p>
<blockquote>
<p>==30536== ERROR SUMMARY: 0 errors from 0 contexts…</p>
</blockquote>
<h2 id="ZeroMQ-多线程"><a href="#ZeroMQ-多线程" class="headerlink" title="ZeroMQ 多线程"></a>ZeroMQ 多线程</h2><p>ZeroMQ 可能是编写多线程 (MT) 应用程序的最佳方式。 如果您习惯了传统的套接字，ZeroMQ 套接字需要进行一些重新调整，而 ZeroMQ 多线程将把您所知道的关于编写多线程应用程序的所有知识，扔到花园里的垃圾堆里，在上面浇上汽油，然后点燃它。 鲜有书籍值得烧掉，但大多数关于并发编程的书籍都值得烧掉。</p>
<p>为了编写完全完美的多线程程序（我的意思是字面意思），<strong>我们不需要互斥锁、锁或任何其他形式的线程间通信，除了通过 ZeroMQ 套接字发送的消息。</strong></p>
<p>“完美的多线程程序”是指易于编写和理解的代码，可以在任何编程语言和任何操作系统上使用相同的设计方法，并且可以跨任意数量的 CPU 进行扩展，不存在等待状态，且不存在衰减的返回值。</p>
<p>如果你花了数年时间学习奇技淫巧来让你的多线程代码正常工作，更不用说高效工作了：诸如锁、信号量和临界区。这些都是徒劳，忘了它们吧，如果我们从 30 多年的并发编程中学到了一个教训，那就是：不要共享状态。这就像两个酒鬼试图分享啤酒。他们是否是好伙伴并不重要。迟早，他们会打架。你加到桌子上的酒鬼越多，他们为了啤酒而互相争吵的次数就越多。悲惨的大多数多线程应用程序看起来就像酒吧的醉鬼打架。</p>
<p>在编写经典的共享状态多线程代码时需要解决的一系列奇怪问题会直接转化成你的血压，因为似乎可以工作的代码在压力下突然失败。一家在错误代码方面拥有世界一流经验的大公司发布了“多线程代码中的 11 个可能问题”列表，其中包括忘记同步、不正确的粒度、读写撕裂、无锁重排序、锁护卫队、两步舞, 和优先级反转。</p>
<p>是的，我们计算了七个问题，而不是十一个。但这不是重点。关键是，你真的希望运行电网或股票市场的代码在下午 3 点开始获得两步锁定验证吗？在一个忙碌的星期四？谁在乎这些术语的实际含义？这不是让我们转向编程的原因，让安全和复杂性不断地螺旋式上升。</p>
<p>一些广泛使用的模型，尽管是整个行业的基础，但从根本上被打破了，共享状态并发就是其中之一。想要开心地使用ZeroMQ编写多线程程序你应该服从以下规则：</p>
<ul>
<li>在其线程中私密地隔离数据，并且永远不要在多个线程中共享数据。唯一的例外是 ZeroMQ 上下文，它是线程安全的。</li>
<li>远离经典的并发机制，如互斥锁、临界区、信号量等。这些是 ZeroMQ 反对的模式。</li>
<li>在进程开始时创建一个 ZeroMQ 上下文，并将其传递给您要通过 <em>inproc</em> 套接字连接的所有线程。</li>
<li>使用 <em>attached</em> 线程在应用程序中创建结构，并使用 PAIR 套接字通过 <em>inproc</em> 将它们连接到它们的父线程。模式是：绑定父套接字，然后创建连接其套接字的子线程。</li>
<li>使用 <em>detached</em> 线程来模拟具有自己上下文的独立任务。通过 tcp 连接它们。稍后您可以将这些移动到独立进程，而无需显着更改代码。</li>
<li>线程之间的所有交互都以 ZeroMQ 消息的形式发生，您可以或多或少地正式定义这些消息。</li>
<li>不要在线程之间共享 ZeroMQ 套接字。 ZeroMQ 套接字不是线程安全的。从技术上讲，可以将套接字从一个线程迁移到另一个线程，但这需要技巧。在线程之间共享套接字的唯一明智的地方是在套接字上的有垃圾回收这样的魔法的语言里。</li>
</ul>
<p>例如，如果您需要在应用程序中启动多个代理，您将希望在各自的线程中运行每个代理。在一个线程中创建代理前端和后端套接字，然后在另一个线程中将套接字传递给代理很容易出错。起初这似乎可行，但在实际使用中会随机失败。记住：<em>不要使用或关闭套接字，除非在创建它们的线程中。</em></p>
<p>如果您遵循这些规则，您可以很容易地构建优雅的多线程应用程序，然后根据需要将线程拆分为单独的进程。应用程序逻辑可以位于线程、进程或节点中：无论您的规模需要什么。</p>
<p>ZeroMQ 使用本地操作系统线程而不是虚拟的“绿色”线程。优点是您不需要学习任何新的线程 API，并且 ZeroMQ 线程可以干净地映射到您的操作系统。您可以使用英特尔的 ThreadChecker 等标准工具来查看您的应用程序在做什么。缺点是本机线程 API 并不总是可移植的，而且如果您有大量线程（数千个），某些操作系统会承受压力。</p>
<p>让我们看看这在实践中是如何工作的。我们将把旧的 Hello World 服务器变成更强大的东西。原始服务器在单个线程中运行。如果每个请求的工作量很低，那很好：一个 ØMQ 线程可以在 CPU 内核上全速运行，无需等待，完成大量工作。但是现实的服务器必须为每个请求做一些重要的工作。当 10,000 个客户端同时访问服务器时，单个内核可能还不够。所以一个现实的服务器会启动多个工作线程。然后它尽可能快地接受请求并将这些请求分发给它的工作线程。工作线程仔细研究工作并最终发送回复。</p>
<p>当然，您可以使用代理代理和外部工作进程来完成所有这些工作，但通常启动一个吞噬 16 个核心的进程任务比启动 16 个进程每个占用一个核心的任务更容易。此外，将工作线程作为线程运行将减少网络跃点、延迟和网络流量。</p>
<p>多线程版本的 Hello World 服务基本上将 broker 和 worker 折叠成一个进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Multi threaded Hello World server</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mtserver</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> ZContext context;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Worker</span><span class="hljs-params">(ZContext context)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>.context = context;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            ZMQ.Socket socket = context.createSocket(SocketType.REP);<br>            socket.connect(<span class="hljs-string">&quot;inproc://workers&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>                <span class="hljs-comment">//  Wait for next request from client (C string)</span><br>                String request = socket.recvStr(<span class="hljs-number">0</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Received request: [&quot;</span> + request + <span class="hljs-string">&quot;]&quot;</span>);<br><br>                <span class="hljs-comment">//  Do some &#x27;work&#x27;</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br><br>                <span class="hljs-comment">//  Send reply back to client (C string)</span><br>                socket.send(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            Socket clients = context.createSocket(SocketType.ROUTER);<br>            clients.bind(<span class="hljs-string">&quot;tcp://*:5555&quot;</span>);<br><br>            Socket workers = context.createSocket(SocketType.DEALER);<br>            workers.bind(<span class="hljs-string">&quot;inproc://workers&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_nbr = <span class="hljs-number">0</span>; thread_nbr &lt; <span class="hljs-number">5</span>; thread_nbr++) &#123;<br>                Thread worker = <span class="hljs-keyword">new</span> Worker(context);<br>                worker.start();<br>            &#125;<br><br>            <span class="hljs-comment">//  Connect work threads to client threads via a queue</span><br>            ZMQ.proxy(clients, workers, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Figure 20 - Multithreaded Server</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig20.png" class="" title="Figure 20">

<p>你现在应该看得懂所有的代码了，它是这么工作的：</p>
<ul>
<li>服务器启动一组工作线程。 每个工作线程创建一个 REP 套接字，然后处理此套接字上的请求。 工作线程就像单线程服务器。 唯一的区别是传输（inproc 而不是 tcp）和绑定连接方向</li>
<li>服务器创建一个 ROUTER 套接字来与客户端通信并将其绑定到其外部接口（通过 tcp）</li>
<li>服务器创建一个 DEALER 套接字与工作线程对话，并将其绑定到其内部接口（通过 inproc）</li>
<li>服务器启动一个连接两个套接字的代理。 代理从所有客户端公平地提取传入请求，并将这些请求分发给工作线程。 它还将回复它的路由来源</li>
</ul>
<p>请注意，在大多数编程语言中创建线程是不可移植的。 POSIX 库是 pthreads，但在 Windows 上，您必须使用不同的 API。 在我们的示例中，pthread_create 调用启动了一个运行我们定义的 worker_routine 函数的新线程。 我们将在第 3 章 - 高级请求-回复模式中看到如何将其包装在可移植的 API 中。</p>
<p>这里的“工作”只是一秒钟的停顿。 我们可以在工作线程中做任何事情，包括与其他节点交谈。 这就是 MT 服务器在 ØMQ 套接字和节点方面的样子。 请注意请求-回复链是 REQ-ROUTER-queue-DEALER-REP。</p>
<h2 id="线程之间的信令（PAIR-Sockets）"><a href="#线程之间的信令（PAIR-Sockets）" class="headerlink" title="线程之间的信令（PAIR Sockets）"></a>线程之间的信令（PAIR Sockets）</h2><p>当您开始使用 ZeroMQ 制作多线程应用程序时，您会遇到如何协调线程的问题。 尽管您可能很想插入 “sleep” 语句，或使用信号量或互斥锁等多线程技术，但您应该使用的唯一机制是 ZeroMQ 消息。 记住酒鬼和啤酒瓶的故事。</p>
<p>让我们创建三个线程，在它们准备好时相互发送信号。 在此示例中，我们在 inproc 传输上使用 PAIR 套接字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Multithreaded relay</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mtrelay</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Step1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> ZContext context;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Step1</span><span class="hljs-params">(ZContext context)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>.context = context;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//  Signal downstream to step 2</span><br>            Socket xmitter = context.createSocket(SocketType.PAIR);<br>            xmitter.connect(<span class="hljs-string">&quot;inproc://step2&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Step 1 ready, signaling step 2&quot;</span>);<br>            xmitter.send(<span class="hljs-string">&quot;READY&quot;</span>, <span class="hljs-number">0</span>);<br>            xmitter.close();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Step2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> ZContext context;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Step2</span><span class="hljs-params">(ZContext context)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>.context = context;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//  Bind to inproc: endpoint, then start upstream thread</span><br>            Socket receiver = context.createSocket(SocketType.PAIR);<br>            receiver.bind(<span class="hljs-string">&quot;inproc://step2&quot;</span>);<br><br>            <span class="hljs-comment">//  Wait for signal</span><br>            receiver.recv(<span class="hljs-number">0</span>);<br>            receiver.close();<br><br>            <span class="hljs-comment">//  Connect to step3 and tell it we&#x27;re ready</span><br>            Socket xmitter = context.createSocket(SocketType.PAIR);<br>            xmitter.connect(<span class="hljs-string">&quot;inproc://step3&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Step 2 ready, signaling step 3&quot;</span>);<br>            xmitter.send(<span class="hljs-string">&quot;READY&quot;</span>, <span class="hljs-number">0</span>);<br>            xmitter.close();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Step3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> ZContext context;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Step3</span><span class="hljs-params">(ZContext context)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>.context = context;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//  Bind to inproc: endpoint, then start upstream thread</span><br>            Socket receiver = context.createSocket(SocketType.PAIR);<br>            receiver.bind(<span class="hljs-string">&quot;inproc://step3&quot;</span>);<br><br>            <span class="hljs-comment">//  Wait for signal</span><br>            receiver.recv(<span class="hljs-number">0</span>);<br>            receiver.close();<br><br>            System.out.println(<span class="hljs-string">&quot;Step 3 ready&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  Step 1 signals to step 2</span><br>            Thread step1 = <span class="hljs-keyword">new</span> Step1(context);<br>            step1.start();<br><br>            <span class="hljs-comment">//  Step 2 relays the signal from step 1 to step 3</span><br>            Thread step2 = <span class="hljs-keyword">new</span> Step2(context);<br>            step2.start();<br><br>            <span class="hljs-comment">//  Step 3 waits for signal from step 2</span><br>            Thread step3 = <span class="hljs-keyword">new</span> Step3(context);<br>            step3.start();<br><br>            step1.join();<br>            step2.join();<br>            step3.join();<br><br>            System.out.println(<span class="hljs-string">&quot;Test successful!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Figure 21 - The Relay Race</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig21.png" class="" title="Figure 21">

<p>这是使用 ZeroMQ 进行多线程处理的经典模式：</p>
<ol>
<li>两个线程使用共享上下文通过 inproc 进行通信。</li>
<li>父线程创建一个套接字，将其绑定到 inproc:@&lt;*&gt;@ 端点，然后 *then// 启动子线程，将上下文传递给它。</li>
<li>子线程创建第二个套接字，将其连接到该 inproc:@&lt;*&gt;@ 端点，然后 *then// 向父线程发出信号，表明它已准备就绪。</li>
</ol>
<p>请注意，使用此模式的多线程代码无法扩展到进程。如果您使用 inproc 和套接字对，则您正在构建一个紧密绑定的应用程序，即您的线程在结构上相互依赖的应用程序。当低延迟非常重要时，请执行此操作。另一种设计模式是松散绑定的应用程序，其中线程有自己的上下文并通过 ipc 或 tcp 进行通信。您可以轻松地将松散绑定的线程分解为单独的进程。</p>
<p>这是我们第一次展示使用 PAIR 套接字的示例。为什么要使用 PAIR？其他套接字组合似乎可以工作，但它们都有可能干扰信号的副作用：</p>
<ul>
<li>您可以将 PUSH 用于发送方，将 PULL 用于接收方。这看起来很简单并且可以工作，但请记住，PUSH 会将消息分发给所有可用的接收者。如果您不小心启动了两个接收器（例如，您已经运行了一个，而您又启动了第二个），您将“丢失”一半的信号。 PAIR 的优点是多于一个连接就拒绝；PAIR是 <strong>排他</strong> 的。</li>
<li>您可以将 DEALER 用作发送方，将 ROUTER 用作接收方。然而，ROUTER 将您的消息包装在一个“信封”中，这意味着您的零大小信号变成了多部分消息。如果您不关心数据并将任何内容视为有效信号，并且您从套接字读取的次数不超过一次，那也没关系。但是，如果您决定发送真实数据，您会突然发现 ROUTER 为您提供“错误”消息。 DEALER 还分发传出消息，带来与 PUSH 相同的风险。</li>
<li>您可以将 PUB 用作发送方，将 SUB 用作接收方。这将完全按照您发送的方式正确传递您的消息，并且 PUB 不会像 PUSH 或 DEALER 那样分发。但是，您需要为订阅者配置一个空订阅，这很烦人。</li>
</ul>
<p>由于这些原因，PAIR 是线程对之间协调的最佳选择。</p>
<h2 id="节点协调"><a href="#节点协调" class="headerlink" title="节点协调"></a>节点协调</h2><p>当您想协调网络上的一组节点时，PAIR 套接字将不再有效。 这是线程和节点策略不同的少数领域之一。 原则上，节点来来去去，而线程通常是静态的。 如果远程节点离开又回来，PAIR 套接字不会自动重新连接。</p>
<p>Figure 22 - Pub-Sub Synchronization</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig22.png" class="" title="Figure 22">

<p>线程和节点之间的第二个显着区别是您通常拥有固定数量的线程，但节点数量可变。 让我们以我们早期的场景之一（天气服务器和客户端）为例，并使用节点协调来确保订阅者在启动时不会丢失数据。</p>
<p>这是应用程序的工作方式：</p>
<p>发布者提前知道它期望有多少订阅者。 这只是它从某个地方得到的一个神奇的数字。</p>
<p>发布者启动并等待所有订阅者连接。 这是节点协调部分。 每个订阅者订阅，然后通过另一个套接字告诉发布者它已准备好。</p>
<p>当发布者连接所有订阅者时，它开始发布数据。</p>
<p>在这种情况下，我们将使用 REQ-REP 套接字流来同步订阅者和发布者。 这是发布者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Synchronized publisher.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syncpub</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * We wait for 10 subscribers</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SUBSCRIBERS_EXPECTED = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  Socket to talk to clients</span><br>            Socket publisher = context.createSocket(SocketType.PUB);<br>            publisher.setLinger(<span class="hljs-number">5000</span>);<br>            <span class="hljs-comment">// In 0MQ 3.x pub socket could drop messages if sub can follow the</span><br>            <span class="hljs-comment">// generation of pub messages</span><br>            publisher.setSndHWM(<span class="hljs-number">0</span>);<br>            publisher.bind(<span class="hljs-string">&quot;tcp://*:5561&quot;</span>);<br><br>            <span class="hljs-comment">//  Socket to receive signals</span><br>            Socket syncservice = context.createSocket(SocketType.REP);<br>            syncservice.bind(<span class="hljs-string">&quot;tcp://*:5562&quot;</span>);<br><br>            System.out.println(<span class="hljs-string">&quot;Waiting for subscribers&quot;</span>);<br>            <span class="hljs-comment">//  Get synchronization from subscribers</span><br>            <span class="hljs-keyword">int</span> subscribers = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (subscribers &lt; SUBSCRIBERS_EXPECTED) &#123;<br>                <span class="hljs-comment">//  - wait for synchronization request</span><br>                syncservice.recv(<span class="hljs-number">0</span>);<br><br>                <span class="hljs-comment">//  - send synchronization reply</span><br>                syncservice.send(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>                subscribers++;<br>            &#125;<br>            <span class="hljs-comment">//  Now broadcast exactly 1M updates followed by END</span><br>            System.out.println(<span class="hljs-string">&quot;Broadcasting messages&quot;</span>);<br><br>            <span class="hljs-keyword">int</span> update_nbr;<br>            <span class="hljs-keyword">for</span> (update_nbr = <span class="hljs-number">0</span>; update_nbr &lt; <span class="hljs-number">1000000</span>; update_nbr++) &#123;<br>                publisher.send(<span class="hljs-string">&quot;Rhubarb&quot;</span>, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            publisher.send(<span class="hljs-string">&quot;END&quot;</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是订阅者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Synchronized subscriber.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syncsub</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            <span class="hljs-comment">//  First, connect our subscriber socket</span><br>            Socket subscriber = context.createSocket(SocketType.SUB);<br>            subscriber.connect(<span class="hljs-string">&quot;tcp://localhost:5561&quot;</span>);<br>            subscriber.subscribe(ZMQ.SUBSCRIPTION_ALL);<br><br>            <span class="hljs-comment">//  Second, synchronize with publisher</span><br>            Socket syncclient = context.createSocket(SocketType.REQ);<br>            syncclient.connect(<span class="hljs-string">&quot;tcp://localhost:5562&quot;</span>);<br><br>            <span class="hljs-comment">//  - send a synchronization request</span><br>            syncclient.send(ZMQ.MESSAGE_SEPARATOR, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">//  - wait for synchronization reply</span><br>            syncclient.recv(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">//  Third, get our updates and report how many we got</span><br>            <span class="hljs-keyword">int</span> update_nbr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String string = subscriber.recvStr(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (string.equals(<span class="hljs-string">&quot;END&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                update_nbr++;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Received &quot;</span> + update_nbr + <span class="hljs-string">&quot; updates.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 Bash shell 脚本将启动十个订阅者，然后是发布者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting subscribers...&quot;</span><br><span class="hljs-keyword">for</span> ((a=0; a&lt;10; a++)); <span class="hljs-keyword">do</span><br>    syncsub &amp;<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting publisher...&quot;</span><br>syncpub<br></code></pre></td></tr></table></figure>
<p>然后我们得到了满意的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs log">Starting subscribers...<br>Starting publisher...<br>Received 1000000 updates<br>Received 1000000 updates<br>...<br>Received 1000000 updates<br>Received 1000000 updates<br></code></pre></td></tr></table></figure>

<p>我们不能假设 SUB 连接将在 REQ/REP 对话框完成时完成。 除非您使用 inproc 传输协议，否则无法保证出站连接将以任何顺序完成。 因此，该示例在订阅和发送 REQ/REP 同步之间进行一秒的强制休眠。</p>
<p>更稳健的模型可能是：</p>
<ul>
<li>发布者打开 PUB 套接字并开始发送“Hello”消息（不是数据）。</li>
<li>订阅者连接 SUB 套接字，当他们收到 Hello 消息时，他们通过 REQ/REP 套接字对告诉发布者。</li>
<li>当发布者得到所有必要的确认后，它开始发送真实数据。</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>ZeroMQ 的消息 API 允许您直接从应用程序缓冲区发送和接收消息，而无需复制数据。我们称之为<strong>零拷贝</strong>，它可以提高某些应用程序的性能。</p>
<p>您应该考虑在高频发送大块内存（数千字节）的特定情况下使用零拷贝。对于短消息或较低的消息速率，使用零拷贝将使您的代码更加混乱和复杂，并且没有明显的好处。像所有优化一样，当您知道它有帮助时使用它，并在之前和之后进行测试权衡。</p>
<p>要进行零拷贝，您使用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-init-data">zmq_msg_init_data()</a> 创建一条消息，该消息引用的数据块已使用 malloc() 分配完成，然后将其传递给 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-send">zmq_msg_send()</a>。当您创建消息时，您还传递了一个函数，ZeroMQ 在发送完消息后将调用该函数来释放数据块。这是最简单的示例，假设缓冲区是在堆上分配的 1,000 字节块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_free</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">void</span> *hint)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span> (data);<br>&#125;<br><span class="hljs-comment">//  Send message from buffer, which we allocate and ZeroMQ will free for us</span><br><span class="hljs-keyword">zmq_msg_t</span> message;<br>zmq_msg_init_data (&amp;message, buffer, <span class="hljs-number">1000</span>, my_free, <span class="hljs-literal">NULL</span>);<br>zmq_msg_send (&amp;message, socket, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>请注意，您不会在发送消息后调用 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-msg-close">zmq_msg_close()</a> - libzmq 将在实际完成发送消息时自动执行此操作。</p>
<p>没有办法在接收时进行零复制：ZeroMQ 为您提供了一个缓冲区，您可以随意存储它，但它不会将数据直接写入应用程序缓冲区。</p>
<p>在编写时，ZeroMQ 的multipart消息与零拷贝很好地协同工作。 在传统的消息传递中，您需要将不同的缓冲区编组到一个可以发送的缓冲区中。 这意味着复制数据。 使用 ZeroMQ，您可以将来自不同来源的多个缓冲区作为单独的消息帧发送。 将每个字段作为长度分隔的帧发送。 对于应用程序来说，它看起来像是一系列发送和接收调用。 但在内部，多个部分被写入网络并通过单个系统调用回读，因此非常高效。</p>
<h2 id="Pub-Sub-消息信封"><a href="#Pub-Sub-消息信封" class="headerlink" title="Pub-Sub 消息信封"></a>Pub-Sub 消息信封</h2><p>在发布-订阅模式中，我们可以将密钥拆分成一个单独的消息帧，我们称之为信封。 如果您想使用 pub-sub 信封，请自己制作。 它是可选的，在之前的 pub-sub 示例中我们没有这样做。 对于简单的情况，使用 pub-sub 信封需要做更多的工作，但对于密钥和数据自然是分开的真实情况来说，它更干净。</p>
<p>Figure 23 - Pub-Sub Envelope with Separate Key</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig23.png" class="" title="Figure 23">

<p>订阅进行前缀匹配。 也就是说，他们查找“所有以 XYZ 开头的消息”。 显而易见的问题是：如何从数据中分隔key，以便前缀匹配不会意外匹配数据。 最好的答案是使用信封，因为匹配不会跨越帧边界。 这是 pub-sub 信封在代码中的外观的极简示例。 这个发布者发送两种类型的消息，A 和 B。</p>
<p>信封包含消息类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pubsub envelope publisher</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">psenvpub</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// Prepare our context and publisher</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            Socket publisher = context.createSocket(SocketType.PUB);<br>            publisher.bind(<span class="hljs-string">&quot;tcp://*:5563&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">// Write two messages, each with an envelope and content</span><br>                publisher.sendMore(<span class="hljs-string">&quot;A&quot;</span>);<br>                publisher.send(<span class="hljs-string">&quot;We don&#x27;t want to see this&quot;</span>);<br>                publisher.sendMore(<span class="hljs-string">&quot;B&quot;</span>);<br>                publisher.send(<span class="hljs-string">&quot;We would like to see this&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>订阅者只需要 B 类消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> guide;<br><br><span class="hljs-keyword">import</span> org.zeromq.SocketType;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ;<br><span class="hljs-keyword">import</span> org.zeromq.ZMQ.Socket;<br><span class="hljs-keyword">import</span> org.zeromq.ZContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pubsub envelope subscriber</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">psenvsub</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// Prepare our context and subscriber</span><br>        <span class="hljs-keyword">try</span> (ZContext context = <span class="hljs-keyword">new</span> ZContext()) &#123;<br>            Socket subscriber = context.createSocket(SocketType.SUB);<br>            subscriber.connect(<span class="hljs-string">&quot;tcp://localhost:5563&quot;</span>);<br>            subscriber.subscribe(<span class="hljs-string">&quot;B&quot;</span>.getBytes(ZMQ.CHARSET));<br><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">// Read envelope with address</span><br>                String address = subscriber.recvStr();<br>                <span class="hljs-comment">// Read message contents</span><br>                String contents = subscriber.recvStr();<br>                System.out.println(address + <span class="hljs-string">&quot; : &quot;</span> + contents);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当您运行这两个程序时，订阅者应该向您显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs log">[B] We would like to see this<br>[B] We would like to see this<br>[B] We would like to see this<br>...<br></code></pre></td></tr></table></figure>
<p>此示例显示订阅过滤器拒绝或接受整个 multipart 消息（密钥加数据）。 你永远不会得到 不完整的 multipart 消息。 如果您订阅了多个发布者并且您想知道他们的地址以便您可以通过另一个套接字向他们发送数据（这是一个典型的用例），请创建一个由三部分组成的消息。</p>
<p>Figure 24 - Pub-Sub Envelope with Sender Address</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig24.png" class="" title="Figure 24">

<h2 id="高水位线"><a href="#高水位线" class="headerlink" title="高水位线"></a>高水位线</h2><p>当您可以在进程之间快速发送消息时，您很快就会发现内存是一种宝贵的资源，而且很容易被填满。除非您了解问题并采取预防措施，否则流程中某处的几秒钟延迟可能会变成导致服务器崩溃的积压。</p>
<p>问题是这样的：假设您有进程 A 以高频率向正在处理它们的进程 B 发送消息。突然 B 变得非常忙碌（垃圾收集、CPU 过载等等），并且在短时间内无法处理消息。一些繁重的垃圾收集可能需要几秒钟，或者如果有更严重的问题，它可能会更长。进程 A 仍在疯狂发送的消息会发生什么？有些将位于 B 的网络缓冲区中。有些会落在以太网线上。有些将位于 A 的网络缓冲区中。其余的将在 A 的内存中积累，积累速度会和 A 发得一样快。如果不采取一些预防措施，A 很容易耗尽内存并崩溃。</p>
<p>这是消息代理的一个经典问题。更让人痛心的是，从表面上看，这是 B 的错，而 B 通常是 A 无法控制的用户编写的应用程序。</p>
<p>答案是什么？一是将问题向上传递。 A 正在从其他地方获取消息。所以告诉整个流程“停止！”等等。这称为<strong>流量控制</strong>。这听起来很合理，但如果你要发送 Twitter 提要呢？您是否想要告诉全世界在 B 程序遭遇程序忙碌时就不要发推文？</p>
<p>流量控制在某些情况下有效，但在其他情况下无效。传输层不能告诉应用层“停止”，就像地铁系统不能告诉大企业一样，“请让你的员工再工作半个小时。我太忙了”。消息传递的答案是设置缓冲区大小的限制，然后当我们达到这些限制时，采取一些明智的行动。在某些情况下（但不适用于地铁系统），答案是丢弃消息。在其他情况下，最好的策略是等待。</p>
<p>ZeroMQ 使用 HWM（高水位线）的概念来定义其内部管道的容量。每个从套接字出来或进入套接字的连接都有自己的管道，以及用于发送和/或接收的 HWM，具体取决于套接字类型。一些套接字（PUB、PUSH）只有发送缓冲区。一些（SUB、PULL、REQ、REP）只有接收缓冲区。一些（DEALER、ROUTER、PAIR）同时具有发送和接收缓冲区。</p>
<p>在 ZeroMQ v2.x 中，HWM 默认是无限的。这很容易，但对于大规模的发布者来说通常也是致命的。在 ZeroMQ v3.x 中，默认设置为 1,000，这样比较明智。如果您仍在使用 ZeroMQ v2.x，您应该始终在您的套接字上设置一个 HWM，无论是 1,000 以匹配 ZeroMQ v3.x 还是考虑到您的消息大小和预期订阅者以求得性能平衡的另一个数字。</p>
<p>当您的套接字达到其 HWM 时，它将根据套接字类型阻止或丢弃数据。 PUB 和 ROUTER 套接字如果到达它们的 HWM 将丢弃数据，而其他套接字类型将阻塞。在 inproc 传输中，发送方和接收方共享相同的缓冲区，因此真正的 HWM 是双方设置的 HWM 的总和。</p>
<p>最后，HWM 并不准确。虽然默认情况下您可能会收到多达 1,000 条消息，但由于 libzmq 实现其队列的方式，实际缓冲区大小可能要小得多（只有一半）。</p>
<h2 id="丢失消息问题的解决方案"><a href="#丢失消息问题的解决方案" class="headerlink" title="丢失消息问题的解决方案"></a>丢失消息问题的解决方案</h2><p>当您使用 ZeroMQ 构建应用程序时，您会不止一次遇到这个问题：丢失您希望收到的消息。 我们整理了一张图表，说明了最常见的原因。</p>
<p>Figure 25 - Missing Message Problem Solver</p>
<img src="/2022/01/16/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%A8%A1%E5%BC%8F/fig25.png" class="" title="Figure 25">

<p>以下是图表内容的摘要：</p>
<ul>
<li>在 SUB 套接字上，使用带有 ZMQ_SUBSCRIBE 的 <a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq-setsockopt">zmq_setsockopt()</a> 设置订阅，否则您将不会收到消息。因为您通过前缀订阅消息，所以如果您订阅“”（一个空订阅），您将获得所有内容。</li>
<li>如果您在 PUB 套接字开始发送数据之后启动 SUB 套接字（即建立与 PUB 套接字的连接），您将丢失它在建立连接之前发布的任何内容。如果这是一个问题，请设置您的体系结构，使 SUB 套接字首先启动，然后 PUB 套接字开始发布。</li>
<li>即使您同步 SUB 和 PUB 套接字，您仍然可能会丢失消息。这是因为在实际创建连接之前不会创建内部队列。如果您可以切换绑定/连接方向，以便 SUB 套接字绑定，并且 PUB 套接字连接，您可能会发现它的工作原理与您预期的一样。</li>
<li>如果您使用 REP 和 REQ 套接字，并且您没有坚持同步发送/接收/发送/接收顺序，ZeroMQ 将报告错误，您可能会忽略它。然后，看起来您正在丢失消息。如果您使用 REQ 或 REP，请坚持发送/接收顺序，并始终在实际代码中检查 ZeroMQ 调用的错误。</li>
<li>如果您使用的是 PUSH 套接字，您会发现第一个连接的 PULL 套接字将获取不公平的消息份额。消息的准确轮换仅在所有 PULL 套接字都成功连接时才会发生，这可能需要几毫秒。作为 PUSH/PULL 的替代方案，对于较低的数据速率，请考虑使用 ROUTER/DEALER 和负载平衡模式。</li>
<li>如果您要跨线程共享套接字，请不要。这将导致随机的怪异和崩溃。</li>
<li>如果您使用 inproc，请确保两个套接字位于相同的上下文中。否则连接侧实际上会失败。另外，先绑定，再连接。 inproc 不像 tcp 那样是断开连接的传输。</li>
<li>如果您使用的是 ROUTER 套接字，很容易通过发送格式错误的身份帧（或忘记发送身份帧）意外丢失消息。一般来说，在 ROUTER 套接字上设置 ZMQ_ROUTER_MANDATORY 选项是个好主意，但也要检查每个发送调用的返回码。</li>
<li>最后，如果你真的不知道出了什么问题，请制作一个重现问题的最小测试用例，并向 ZeroMQ 社区寻求帮助。</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2022/01/16/%E9%AB%98%E7%BA%A7%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94%E6%A8%A1%E5%BC%8F/">← Prev 高级请求应答模式</a><span style="color: #fe2"> | </span><a href="/2021/11/14/ZeroMQ%E5%9F%BA%E7%A1%80/">ZMQ(3.2)官网文档翻译 第一章——基础知识 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.ZhaiYe</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">8</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">10</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">6</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Sockets-and-Patterns"><span class="toc-number">1.</span> <span class="toc-text">Chapter 2 - Sockets and Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-API"><span class="toc-number">1.1.</span> <span class="toc-text">Socket API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8F%92%E5%85%A5%E6%8B%93%E6%89%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">将套接字插入拓扑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">收发消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%92%AD%E4%BC%A0%E8%BE%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">单播传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZeroMQ-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%AD%E7%AB%8B%E7%9A%84%E8%BD%BD%E4%BD%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">ZeroMQ 不是一个中立的载体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">I&#x2F;O 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">消息模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">高级消息传递模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E6%B6%88%E6%81%AF%E5%85%B1%E4%BA%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">和消息共事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.1.9.</span> <span class="toc-text">处理多个套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multipart%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">Multipart消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">动态发现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%98%9F%E5%88%97%EF%BC%88DEALER-%E5%92%8C-ROUTER-%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">共享队列（DEALER 和 ROUTER 套接字）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZeroMQ%E7%9A%84%E5%86%85%E7%BD%AE%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.4.</span> <span class="toc-text">ZeroMQ的内置代理功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%A1%A5%E6%8E%A5"><span class="toc-number">1.2.5.</span> <span class="toc-text">传输桥接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E5%92%8C-ETERM"><span class="toc-number">1.3.</span> <span class="toc-text">处理错误和 ETERM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.4.</span> <span class="toc-text">处理中断信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">检测内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZeroMQ-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">ZeroMQ 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BF%A1%E4%BB%A4%EF%BC%88PAIR-Sockets%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">线程之间的信令（PAIR Sockets）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8D%8F%E8%B0%83"><span class="toc-number">1.8.</span> <span class="toc-text">节点协调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.9.</span> <span class="toc-text">零拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pub-Sub-%E6%B6%88%E6%81%AF%E4%BF%A1%E5%B0%81"><span class="toc-number">1.10.</span> <span class="toc-text">Pub-Sub 消息信封</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="toc-number">1.11.</span> <span class="toc-text">高水位线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.12.</span> <span class="toc-text">丢失消息问题的解决方案</span></a></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2021 Guihub, Inc.</span></nobr><wbr><nobr><span class="text-title">License</span><span class="text-content">MIT License</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">ZhaiYe</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>